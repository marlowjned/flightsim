#ifndef RPA_TABLE_INTERPOLATOR_H
#define RPA_TABLE_INTERPOLATOR_H

#include <vector>
#include <string>
#include <map>
#include <array>

/**
 * RPATableInterpolator
 *
 * Loads and interpolates RPA performance tables generated by generate_rpa_tables.js
 * Uses trilinear interpolation for 3D lookup (Pc, O/F, Pa)
 */
class RPATableInterpolator {
public:
    // Performance data structure
    struct PerformanceData {
        double Cf;          // Thrust coefficient (dimensionless)
        double Cstar;       // Characteristic velocity (m/s)
        double Isp;         // Specific impulse (s)
        double Ve;          // Exit velocity (m/s)
        double Pe;          // Exit pressure (psi)
        double gamma;       // Ratio of specific heats
    };

    RPATableInterpolator();
    ~RPATableInterpolator();

    /**
     * Load RPA table from CSV file
     * @param filename Path to CSV file generated by generate_rpa_tables.js
     * @return true if successful, false otherwise
     */
    bool loadTable(const std::string& filename);

    /**
     * Get performance data at specific operating conditions using trilinear interpolation
     * @param Pc Chamber pressure (psi)
     * @param OF Mixture ratio (oxidizer/fuel mass ratio)
     * @param Pa Ambient pressure (psi)
     * @return Interpolated performance data
     */
    PerformanceData getPerformance(double Pc, double OF, double Pa) const;

    /**
     * Check if table is loaded and valid
     */
    bool isValid() const { return m_isLoaded; }

    /**
     * Get table bounds for validation
     */
    void getBounds(double& Pc_min, double& Pc_max,
                   double& OF_min, double& OF_max,
                   double& Pa_min, double& Pa_max) const;

private:
    // Table entry structure
    struct TableEntry {
        double Pc;          // Chamber pressure (psi)
        double OF;          // Mixture ratio
        double Pa;          // Ambient pressure (psi)
        PerformanceData data;
    };

    // Storage
    std::vector<TableEntry> m_table;

    // Unique sorted axis values for interpolation
    std::vector<double> m_Pc_values;
    std::vector<double> m_OF_values;
    std::vector<double> m_Pa_values;

    // 3D index lookup: [Pc_idx][OF_idx][Pa_idx] -> table entry index
    std::map<std::array<int, 3>, size_t> m_indexMap;

    bool m_isLoaded;

    // Helper functions
    void buildInterpolationStructure();

    /**
     * Find bounding indices for a value in a sorted array
     * @param values Sorted array of values
     * @param value Value to find bounds for
     * @param idx0 Output: lower bound index
     * @param idx1 Output: upper bound index
     * @param t Output: interpolation factor [0,1]
     */
    void findBounds(const std::vector<double>& values, double value,
                    int& idx0, int& idx1, double& t) const;

    /**
     * Trilinear interpolation
     * @param c000-c111 Corner values of the cube
     * @param tx, ty, tz Interpolation factors [0,1] for each dimension
     */
    double trilinearInterp(double c000, double c001, double c010, double c011,
                          double c100, double c101, double c110, double c111,
                          double tx, double ty, double tz) const;

    /**
     * Get table entry at specific grid indices
     * Returns nullptr if indices are out of bounds
     */
    const TableEntry* getEntry(int Pc_idx, int OF_idx, int Pa_idx) const;
};

#endif // RPA_TABLE_INTERPOLATOR_H
